use crate::git::GitDiffFile;
use serde::Deserialize;
use serde_json;
use similar::{ChangeTag, TextDiff};
use std::fmt::Write;

#[derive(Deserialize, Clone, Copy, PartialEq)]
pub enum ExportFormat {
    Markdown,
    Json,
    Xml,
    Txt,
}

#[derive(Deserialize, Clone, Copy, PartialEq, Debug)]
pub enum ExportLayout {
    Split,    // 左右/上下分离 (Full Context)
    Unified,  // 编辑器风格 (Full Context with markers)
    GitPatch, // 标准 Git Diff (Minimal Context)
}

/// Export files in various formats
pub fn generate_export_content(
    files: Vec<GitDiffFile>,
    format: ExportFormat,
    layout: ExportLayout,
) -> String {
    match format {
        ExportFormat::Markdown => to_markdown(files, layout),
        ExportFormat::Json => to_json(files, layout),
        ExportFormat::Xml => to_xml(files, layout),
        ExportFormat::Txt => to_custom_text(files, layout),
    }
}

fn generate_diff_string(original: &str, modified: &str, path: &str, layout: ExportLayout) -> String {
    let diff = TextDiff::from_lines(original, modified);
    let mut output = String::new();

    match layout {
        ExportLayout::Unified => {
            // Unified: show full file with markers
            for change in diff.iter_all_changes() {
                let sign = match change.tag() {
                    ChangeTag::Delete => "-",
                    ChangeTag::Insert => "+",
                    ChangeTag::Equal => " ",
                };
                let _ = write!(output, "{}{}", sign, change);
            }
        }
        ExportLayout::GitPatch => {
            // Git Patch style with header, limited context
            let _ = writeln!(output, "diff --git a/{} b/{}", path, path);
            let _ = writeln!(output, "--- a/{}", path);
            let _ = writeln!(output, "+++ b/{}", path);
            let _ = write!(output, "{}", diff.unified_diff());
        }
        _ => {} // Split 模式不使用此函数
    }
    output
}

/// Markdown format
fn to_markdown(files: Vec<GitDiffFile>, layout: ExportLayout) -> String {
    let mut output = String::new();
    let _ = writeln!(output, "# Git Diff Export\n");
    let _ = writeln!(output, "> Generated by CodeForge AI\n");

    for file in files {
        let ext = file.path.split('.').last().unwrap_or("txt");
        let _ = writeln!(output, "## File: {} ({})\n", file.path, file.status);

        if layout == ExportLayout::Split {
            if !file.original_content.is_empty() {
                let _ = writeln!(output, "### Original Version");
                let _ = writeln!(output, "```{}", ext);
                let _ = writeln!(output, "{}", file.original_content);
                let _ = writeln!(output, "```\n");
            }
            if !file.modified_content.is_empty() {
                let _ = writeln!(output, "### Modified Version");
                let _ = writeln!(output, "```{}", ext);
                let _ = writeln!(output, "{}", file.modified_content);
                let _ = writeln!(output, "```\n");
            }
        } else {
            let diff_content = generate_diff_string(
                &file.original_content,
                &file.modified_content,
                &file.path,
                layout
            );
            
            let title = if layout == ExportLayout::Unified { "### Full Context Diff" } else { "### Git Patch" };
            let _ = writeln!(output, "{}", title);
            let _ = writeln!(output, "```diff");
            let _ = writeln!(output, "{}", diff_content);
            let _ = writeln!(output, "```\n");
        }
        let _ = writeln!(output, "---\n");
    }
    output
}

/// JSON format
fn to_json(files: Vec<GitDiffFile>, layout: ExportLayout) -> String {
    let export_data: Vec<serde_json::Value> = files.into_iter().map(|f| {
        let content = if layout == ExportLayout::Split {
            serde_json::json!({
                "original": f.original_content,
                "modified": f.modified_content
            })
        } else {
            serde_json::json!({
                "diff": generate_diff_string(&f.original_content, &f.modified_content, &f.path, layout)
            })
        };

        serde_json::json!({
            "path": f.path,
            "status": f.status,
            "layout": format!("{:?}", layout),
            "content": content
        })
    }).collect();

    serde_json::to_string_pretty(&export_data).unwrap_or_else(|_| "[]".to_string())
}

/// XML format
fn to_xml(files: Vec<GitDiffFile>, layout: ExportLayout) -> String {
    let mut output = String::new();
    output.push_str("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
    output.push_str("<git_diff_export>\n");

    for file in files {
        let _ = writeln!(output, "  <file path=\"{}\" status=\"{}\">", escape_xml_attr(&file.path), file.status);

        if layout == ExportLayout::Split {
            if !file.original_content.is_empty() {
                output.push_str("    <original><![CDATA[\n");
                output.push_str(&file.original_content);
                output.push_str("\n]]></original>\n");
            }
            if !file.modified_content.is_empty() {
                output.push_str("    <modified><![CDATA[\n");
                output.push_str(&file.modified_content);
                output.push_str("\n]]></modified>\n");
            }
        } else {
            let diff = generate_diff_string(&file.original_content, &file.modified_content, &file.path, layout);
            output.push_str("    <diff><![CDATA[\n");
            output.push_str(&diff);
            output.push_str("\n]]></diff>\n");
        }
        output.push_str("  </file>\n");
    }
    output.push_str("</git_diff_export>");
    output
}

/// TXT format
fn to_custom_text(files: Vec<GitDiffFile>, layout: ExportLayout) -> String {
    let mut output = String::new();

    for file in files {
        let _ = writeln!(output, "==================================================================");
        let _ = writeln!(output, "FILE: {}  STATUS: {}", file.path, file.status);
        let _ = writeln!(output, "==================================================================");

        if layout == ExportLayout::Split {
            if !file.original_content.is_empty() {
                let _ = writeln!(output, "<<<<<<<< ORIGINAL VERSION START");
                let _ = writeln!(output, "{}", file.original_content);
                let _ = writeln!(output, ">>>>>>>> ORIGINAL VERSION END");
                let _ = writeln!(output, "");
            }
            if !file.modified_content.is_empty() {
                let _ = writeln!(output, "<<<<<<<< MODIFIED VERSION START");
                let _ = writeln!(output, "{}", file.modified_content);
                let _ = writeln!(output, ">>>>>>>> MODIFIED VERSION END");
                let _ = writeln!(output, "");
            }
        } else {
            let diff = generate_diff_string(&file.original_content, &file.modified_content, &file.path, layout);
            let _ = writeln!(output, "{}", diff);
        }
        let _ = writeln!(output, "\n");
    }
    output
}

fn escape_xml_attr(s: &str) -> String {
    s.replace("&", "&amp;").replace("\"", "&quot;").replace("'", "&apos;").replace("<", "&lt;").replace(">", "&gt;")
}