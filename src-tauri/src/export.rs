use crate::git::GitDiffFile;
use serde::Deserialize;
use serde_json;
use std::fmt::Write; // 用于高效字符串拼接

#[derive(Deserialize)]
pub enum ExportFormat {
    Markdown,
    Json,
    Xml,
    Txt,
}

/// 主导出函数
pub fn generate_export_content(files: Vec<GitDiffFile>, format: ExportFormat) -> String {
    match format {
        ExportFormat::Markdown => to_markdown(files),
        ExportFormat::Json => to_json(files),
        ExportFormat::Xml => to_xml(files),
        ExportFormat::Txt => to_custom_text(files),
    }
}

/// 1. Markdown 格式 (AI 理解最佳)
fn to_markdown(files: Vec<GitDiffFile>) -> String {
    let mut output = String::new();
    let _ = writeln!(output, "# Git Diff Export\n");
    let _ = writeln!(output, "> Generated by CodeForge AI\n");

    for file in files {
        let _ = writeln!(output, "## File: {} ({})\n", file.path, file.status);
        
        // 获取文件扩展名以启用语法高亮
        let ext = file.path.split('.').last().unwrap_or("txt");

        if !file.original_content.is_empty() {
            let _ = writeln!(output, "### Original Version");
            let _ = writeln!(output, "```{}", ext);
            let _ = writeln!(output, "{}", file.original_content);
            let _ = writeln!(output, "```\n");
        }

        if !file.modified_content.is_empty() {
            let _ = writeln!(output, "### Modified Version");
            let _ = writeln!(output, "```{}", ext);
            let _ = writeln!(output, "{}", file.modified_content);
            let _ = writeln!(output, "```\n");
        }
        
        let _ = writeln!(output, "---\n");
    }
    output
}

/// 2. JSON 格式 (结构化最强，Token 消耗最大)
fn to_json(files: Vec<GitDiffFile>) -> String {
    serde_json::to_string_pretty(&files).unwrap_or_else(|_| "[]".to_string())
}

/// 3. XML 格式 (适合严格解析)
fn to_xml(files: Vec<GitDiffFile>) -> String {
    let mut output = String::new();
    output.push_str("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
    output.push_str("<git_diff_export>\n");

    for file in files {
        let _ = writeln!(
            output, 
            "  <file path=\"{}\" status=\"{}\">", 
            escape_xml_attr(&file.path), 
            file.status
        );

        if !file.original_content.is_empty() {
            output.push_str("    <original><![CDATA[\n");
            output.push_str(&file.original_content);
            output.push_str("\n]]></original>\n");
        }

        if !file.modified_content.is_empty() {
            output.push_str("    <modified><![CDATA[\n");
            output.push_str(&file.modified_content);
            output.push_str("\n]]></modified>\n");
        }

        output.push_str("  </file>\n");
    }

    output.push_str("</git_diff_export>");
    output
}

/// 4. 自定义 TXT 格式 (清晰度高，比JSON省Token)
fn to_custom_text(files: Vec<GitDiffFile>) -> String {
    let mut output = String::new();

    for file in files {
        let _ = writeln!(output, "==================================================================");
        let _ = writeln!(output, "FILE: {}  STATUS: {}", file.path, file.status);
        let _ = writeln!(output, "==================================================================");

        if !file.original_content.is_empty() {
            let _ = writeln!(output, "<<<<<<<< ORIGINAL VERSION START");
            let _ = writeln!(output, "{}", file.original_content);
            let _ = writeln!(output, ">>>>>>>> ORIGINAL VERSION END");
            let _ = writeln!(output, "");
        }

        if !file.modified_content.is_empty() {
            let _ = writeln!(output, "<<<<<<<< MODIFIED VERSION START");
            let _ = writeln!(output, "{}", file.modified_content);
            let _ = writeln!(output, ">>>>>>>> MODIFIED VERSION END");
            let _ = writeln!(output, "");
        }
        let _ = writeln!(output, "\n");
    }
    output
}

// 简单的 XML 属性转义 helper
fn escape_xml_attr(s: &str) -> String {
    s.replace("&", "&amp;")
     .replace("\"", "&quot;")
     .replace("'", "&apos;")
     .replace("<", "&lt;")
     .replace(">", "&gt;")
}