# 🚀 项目功能设计方案：智能上下文依赖分析 (Smart Focus)

| 文档版本 | V1.0 |
| :--- | :--- |
| **状态** | 规划中 |
| **优先级** | P0 (高) |
| **涉及端** | Rust 后端, React 前端 |

---

## 1. 核心背景与痛点分析 (Background & Problem)

### 1.1 当前痛点
目前 CodeForge AI 的工作模式是基于**目录结构**的文件选择。当用户需要让 AI 修改某个具体功能时，往往面临两难：
1.  **全量投喂**：将整个文件夹发给 AI。
    *   **后果**：消耗大量 Token（费用高）；无关代码干扰 AI 注意力，降低回复准确度；容易触碰上下文窗口上限。
2.  **手动挑选**：用户凭记忆手动勾选相关文件。
    *   **后果**：操作繁琐；极易遗漏关键的依赖文件（如工具函数、类型定义），导致 AI 生成的代码不可运行（幻觉）。

### 1.2 目标 (Goal)
实现 **“智能聚焦模式 (Smart Focus)”**。
当用户选中一个核心文件时，系统利用**静态代码分析**技术，自动识别并关联该文件的：
*   **上游 (Upstream)**：引用了该文件的模块（评估修改影响范围）。
*   **下游 (Downstream)**：该文件依赖的模块（提供必要的上下文定义）。

---

## 2. 总体架构设计 (Architecture Design)

为了保证性能并最小化对主线程的阻塞，核心分析逻辑将下沉至 **Rust 后端**，前端仅负责展示和交互。

### 2.1 系统分层图

```mermaid
graph TD
    subgraph "前端 (React/Tauri UI)"
        UI[文件树视图] -->|1. 触发分析指令| Bridge[Tauri Bridge]
        Bridge -->|4. 返回依赖图数据| UI
        UI -->|5. 交互: 自动勾选依赖文件| Store[Zustand Store]
    end

    subgraph "后端 (Rust Core)"
        Bridge --> Analyzer[依赖分析引擎]
        
        Analyzer --> Scanner[文件扫描器 (Walkdir)]
        Analyzer --> Parser[语法解析器 (Tree-sitter)]
        Analyzer --> Resolver[路径解析器 (Path Resolution)]
        
        Parser --> AST[抽象语法树]
        AST --> Extractor[Import 提取器]
        
        Extractor --> GraphBuilder[图谱构建器 (Petgraph)]
    end
```

### 2.2 技术选型 (Tech Stack)

| 模块 | 选型 | 理由 |
| :--- | :--- | :--- |
| **解析引擎** | **Tree-sitter** | 业界标准（GitHub/VSCode采用），支持多语言，**增量解析速度极快**，容错性强。 |
| **并行计算** | **Rayon** | 利用 Rust 的数据并行能力，多核 CPU 并发解析文件，将扫描时间压缩至毫秒级。 |
| **图数据结构** | **自定义邻接表** | 针对文件依赖的轻量级实现，内存占用极低。 |
| **支持语言** | TS/JS, Py, Java, Go, Rust | 覆盖 90% 的主流开发场景。 |

---

## 3. 详细实现方案 (Implementation Details)

### 3.1 核心流程：解析与构图

后端将维护一个 `DependencyGraph` 单例，在项目加载时初始化。

1.  **文件扫描**：使用 `walkdir` 遍历项目根目录，过滤掉 `.git`, `node_modules` 等无关目录。
2.  **并行解析**：
    *   使用 `rayon` 将文件列表分发到线程池。
    *   根据文件后缀加载对应的 `tree-sitter-<language>` 解析器。
    *   执行 Query（如 `(import_statement ...)`）提取引用路径。
3.  **路径标准化 (Path Resolution)**：
    *   **难点**：代码中的 `import './utils'` 需要转换为绝对路径 `C:/Project/src/utils.ts`。
    *   **策略**：
        *   解析相对路径 (`./`, `../`)。
        *   自动补全后缀 (`.ts`, `.js`, `/index.js` 等)。
        *   *注：路径别名（如 `@/components`）在 V1 版本采用启发式匹配，V2 版本解析配置文件。*
4.  **图谱构建**：建立双向索引（谁引用了我，我引用了谁）。

### 3.2 性能与包体积评估

针对领导层可能关心的“软件膨胀”问题做专门说明：

*   **包体积影响**：
    *   虽然 NPM 上的 Tree-sitter 包很大（含 WASM/JS 绑定），但 Rust 编译时**仅包含核心 C 代码**。
    *   **预计增量**：集成 5-6 种主流语言解析器，最终 Release 包体积增加约 **2MB - 3MB**。
    *   **结论**：相对于功能的巨大价值，此体积增长完全可接受。

*   **运行时性能**：
    *   **内存**：AST 解析后即释放，仅保留图结构。10,000 个文件的项目，图结构内存占用 **< 10MB**。
    *   **速度**：基于 Rayon 并行处理，扫描 1000 个文件的混合项目耗时预计 **< 1 秒**。

### 3.3 数据结构定义 (Rust)

```rust
pub struct DependencyGraph {
    // 核心映射：文件路径 -> 依赖关系
    nodes: HashMap<String, FileNode>,
}

struct FileNode {
    path: String,
    language: LanguageType,
    // 上游：谁引用了我 (用于评估影响)
    imported_by: HashSet<String>, 
    // 下游：我引用了谁 (用于补充上下文)
    imports: HashSet<String>,     
}
```

---

## 4. UI/UX 交互设计

不引入复杂的图表组件，保持界面的整洁，将功能融入现有文件树。

### 4.1 交互入口
在文件树 (Explorer) 的文件项上右键，新增菜单：
*   **🎯 Focus Context (智能聚焦)**
    *   子选项：**Include Dependencies (向下集成)** - 引入该文件需要的代码。
    *   子选项：**Include Impacted Files (向上集成)** - 引入受该文件影响的代码。
    *   子选项：**Full Context (双向集成)** - 包含上下游一层。

### 4.2 视觉反馈
当通过智能聚焦选中文件时，在文件右侧显示微型 Badge：
*   `[Dep]` (蓝色)：表示它是作为依赖被引入的。
*   `[Ref]` (橙色)：表示它是引用者。

---

## 5. 实施路线图 (Roadmap)

我们建议分为三个阶段迭代，**第一周即可交付 MVP**。

### 📅 第一阶段：核心引擎与基础支持 (MVP)
*   **目标**：后端能够解析 TS/JS 和 Python 文件，前端能通过右键自动勾选直接依赖。
*   **耗时**：3-4 天。
*   **内容**：
    1.  引入 Rust 依赖 (`tree-sitter`, `rayon` 等)。
    2.  编写 TS/JS 和 Python 的 Import 提取逻辑。
    3.  实现简单的相对路径解析。
    4.  前端右键菜单对接。

### 📅 第二阶段：多语言支持与路径增强
*   **目标**：覆盖主流语言，解决路径别名问题。
*   **耗时**：3-4 天。
*   **内容**：
    1.  增加 Java, Go, Rust 支持。
    2.  实现“启发式路径搜索”解决 `@/` 等别名问题。
    3.  优化大项目扫描性能（添加缓存机制）。

### 📅 第三阶段：可视化图谱 (可选)
*   **目标**：提供上帝视角的依赖图。
*   **耗时**：待定。
*   **内容**：引入 React Flow，绘制交互式文件依赖图。

---

## 6. 风险与对策 (Risk Analysis)

| 风险点 | 描述 | 对策方案 |
| :--- | :--- | :--- |
| **动态引用解析** | 无法解析 `require(variable)` 这种动态路径。 | **静态分析局限性**。V1版本忽略此类情况，这类写法在现代工程中占比很低。 |
| **路径别名复杂** | `tsconfig.json` 配置极其复杂时可能解析失败。 | 实现**模糊匹配回退机制**：如果精确路径找不到，尝试在项目中搜索同名文件。 |
| **构建时间增加** | 引入 C 代码编译会导致 CI/CD 构建时间变长。 | 在 GitHub Actions 中增加 Rust 构建缓存 (`swatinem/rust-cache`)。 |

---

## 7. 结论 (Conclusion)

引入“文件级依赖分析”将使 CodeForge AI 从一个单纯的“文件打包工具”进化为**“懂代码结构的 AI 助手”**。

这不仅解决了用户节省 Token 的痛点，也为未来实现更高级的功能（如：自动代码审查、影响面评估）打下了坚实的数据基础。技术路径清晰，风险可控，建议立即启动。